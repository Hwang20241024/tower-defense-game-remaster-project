# 1. 만든기능.
## 1-1. packetParser
- [기능 소개] 
1. 클라이언트에서 받은 패킷을 헤더와 페이로드로 분리하고, packetType, sequence, payload, offset을 반환합니다.

## 1-2. spawnMonsterHandler
- [기능 소개] 
1. 클라이언트에서 몬스터 리스폰을 요청하면, 서버는 해당 클라이언트에 응답하고 같은 세션에 있는 클라이언트들에게 몬스터 스폰을 브로드캐스트합니다. 
2. 브로드캐스트를 통해 서버와 클라이언트는 동일한 몬스터 배열을 가지게 됩니다.


```
// 예시

📦 서버 
 ┣ 📂세션 1  = (몬스터 배열 : 10)
 ┃  ┣📜클라이언트 1 = (몬스터 배열 : 10)
 ┃  ┗📜클라이언트 2 = (몬스터 배열 : 10)
 ┣ 📂세션 2 = (몬스터 배열 : 7)
 ┃  ┣📜클라이언트 1 = (몬스터 배열 : 7)
 ┃  ┗📜클라이언트 2 = (몬스터 배열 : 7)

```
## 1-3. monsterDeathHandler
- [기능 소개]
1. 클라이언트에서 몬스터 죽음을 요청하면, 서버는 해당 클라이언트에 응답하고 같은 세션에 있는 클라이언트들에게 몬스터 삭제를 브로드캐스트합니다.
2. 브로드캐스트를 통해 서버와 클라이언트는 동일한 몬스터 배열을 가지게 됩니다.

## 1-4. MonsterManager
- [기능 소개]
1. 몬스터를 세션마다 생성, 검색, 삭제를 관리하는 매니저입니다.
2. addMonster : 클라이언트 기준으로 몬스터를 랜덤하게 생성합니다
3. getMonstersArr : 현재 세션에 있는 몬스터를 "배열" 형태로 반환합니다.
4. getLastMonster : 마지막 몬스터 정보를 반환합니다.
5. getMonstersMap : 현재 세션에 있는 몬스터를 "맵" 형태로 반환합니다.
6. removeMonster : 세션에 있는 몬스터를 삭제합니다.

## 1-5. createResponse
- [기능 소개]
1. 공통 헤더와 페이로드를 직렬화하는 함수입니다.
2. 페이로드는 동적으로 oneof 방식으로 직렬화합니다.


# 2. 트러블 슈팅.
## 2-1. 프로토버퍼 자료형 문제
1. 문제 : packetParser를 위해 공통 버퍼를 프로토 파일에 정의하고 사용하는 과정에서 발생.
2. 원인 : 프로토버퍼에는 ushort와 ubyte 자료형이 존재하지 않음.
3. 해결 : 공통 버퍼를 프로토 파일에 정의하지 않고, 직접 헤더와 페이로드를 분리하여 사용.

## 2-2. packetParser의 페이로드 역직렬화 문제
1. 문제 : 패킷 이름으로 정의한 이름을 사용해 역직렬화하니 페이로드가 제대로 역직렬화되지 않는 문제가 발생.
2. 원인 : 클라이언트에서 oneof 방식으로 직렬화하여 발생한 문제.
3. 해결 : 서버에서도 oneof 방식으로 역직렬화하여 문제를 해결.

## 2-3. createResponse의 페이로드 부분만 외부에서 직렬화했을 때 발생한 문제
1. 문제 : 각 핸들러에서 페이로드를 불필요하게 직렬화하여 코드가 늘어남.
2. 원인 : createResponse의 내부에서 페이로드 부분만 직렬화하지 않아서 발생.
3. 해결 : createResponse의 내부에서 oneof 방식으로 동적으로 페이로드를 직렬화하도록 변경.

# 3. 프로젝트 소감. 
1. 프로토버퍼를 이용한 TCP 통신에 대해 좀 더 익숙해졌습니다. 
2. 현재 서버와 클라이언트 구조는 사실상 클라이언트가 대부분 처리하고, 서버는 응답만 하는 에코 서버에 가까운 구조입니다. 이러한 방식의 문제점을 알게 되었고, 많은 것을 배울 수 있었던 팀 프로젝트였습니다.

# 4. 보완했으면 좋았을 점
1. 서버 역할 확장
- 서버가 게임 상태를 더 많이 관리하고, 클라이언트는 단순히 명령만 요청하는 구조로 설계했으면 좋았을 것 같습니다.
- 예를 들어, 서버가 게임의 "싱글 소스 오브 트루스(Single Source of Truth)" 역할을 맡아 데이터를 중앙에서 관리하면 더 안정적이고 효율적인 시스템이 될 것입니다.
- **Single Source of Truth (SSOT)**
- 시스템에서 데이터를 한 곳에서만 관리하고, 모든 다른 요소가 이 데이터를 참조하도록 설계하는 원칙.

2. 테스트와 성능 개선
- 클라이언트 수가 많아질 경우 브로드캐스트 성능에 저하가 발생할 수 있습니다.
- 비동기 처리나 이벤트 기반 구조를 도입해 부하를 분산하는 방법을 연구해보면 좋을 것 같습니다.

3. 로그 시스템 도입
- 이번 프로젝트에서 다양한 핸들러가 생겼는데, 이를 기반으로 서버/클라이언트에서 동작을 추적하는 로깅 시스템을 도입했으면 좋았을 것 같습니다.
- 이를 통해 디버깅과 유지보수의 난이도가 낮아질 것입니다.